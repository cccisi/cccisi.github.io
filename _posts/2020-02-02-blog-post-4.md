---
title: 'Vivado UltraFast设计方法指南(UG949)'
date: 2020-02-02
permalink: /posts/2020/02/02/blog-post-4/
tags:
  - UG949
  - FPGA
  - Hardware design
---

使用XILINX的设计方法学能够帮助设计者更好地利用资源。特别关注频率，面积，功耗这些指标、

- 注意logic level的概念，指的是两层寄存器之间有几层LUT组合逻辑。

控制信号集
======
## 复位

* 如果需要复位，赛灵思建议代码同步复位。与异步复位相比，同步复位拥有众多优势。

* 使用复位时，确保该程序语句中的所有寄存器都有复位。

## 时钟使能

* 如果正确使用，时钟使能能够显著地降低系统功耗，同时对面积或性能的影响极小。
* 所有寄存器的置位/复位功能的优先级均高于时钟使能，不论是异步置位/复位还是同步置位/复位都是如此。为取得最佳结果，赛灵思建议在同步块中的 if/else 结构中，应一直在时钟使能 （如有必要使用）之前对置位/复位进行编码。优先对时钟使能进行编码会强制复位进入数据路径，并导致产生更多逻辑。 示例：（\* DIRECT_ENABLE = "ture" \*）

* 将 DIRECT_ENABLE 属性添加到端口/信号，可以使能信号 (en) 连接到寄存器的CE引脚。

了解器件调用
======
* 三值加法（ternary addition）所使用的资源大致与二值加法相当，因此一次三值加法可以比两次二值加法省一半的资源。
- one LUT per 2-bit/3-bit addition is used.

* 利用DSP内部流水线资源
- DSP blocks have  three levels of pipelining resources inside them. Pipelining properly for logic inferred into the DSP block can greatly improve performance and power.

* 利用移位寄存器
- Two SRLs with depths of 16 bits or less can be mapped into a single LUT, and single SRLs up to 32 bits can also be mapped into a single LUT.

* 选通器 For conditional code resulting in standard MUX components:
- A 4-to-1 MUX can be implemented into a single LUT, resulting in one logic level.
- An 8-to-1 MUX can be implemented into two LUTs and a MUXF7 component, still resulting in effectively one logic (LUT) level.
- A 16-to-1 MUX can be implemented into four LUTs and a combination of MUXF7 and MUXF8 resources, still resulting in effectively one logic (LUT) level.
* 对通用逻辑而言，考虑给定寄存器具有唯一的输入数。根据这个数量，就可以估计出可能实现的 LUT 数量和逻辑层数
量。一般来说， 6 个或六个以下输入会产生一个逻辑层。理论上两个逻辑层可以管理多达 36 个输入。但实际上两个逻
辑层最多仅能管理 20 个输入。一般来说如果输入数量越多，逻辑等式越复杂，那么需要的 LUT 和逻辑层就越多。
- For general logic, take into account the number of unique inputs for a given register. From
that number, an estimation of LUTs and logic levels can be achieved. In general, 6 inputs or
fewer always results in a single logic level. Theoretically, two levels of logic can manage up
to 36 inputs. However, for all practical purposes, you should assume that approximately 20
inputs is the maximum that can be managed with two levels of logic. In general, the larger
the number of inputs and the more complex the logic equation, the more LUTs and logic
levels are required.

## 调用RAM和ROM
* 隐式调用
- 优势：
° 高度可移植
° 便于阅读和理解
° 自我文档化
° 快速仿真
- 不足：
° 不能访问所有可用的 RAM 配置
° 可能产生不够理想的结果
调用 RAM 时，赛灵思建议使用 Vivado 工具中提供的 HDL 模板。
* 赛灵思可参数化宏 (XPM)
- 优势：
° 可在赛灵思器件系列之间移植
° 快速仿真
° 支持不对称宽度
° 可预测的 QoR
- 不足：
° 仅支持 XPM 选项

* 直接实例化 RAM 原语
- 优势：
° 对实现方案有最高控制权限
° 能访问块的各项功能
- 不足：
° 代码可移植性差
° 功能和用途冗长繁琐，难以理解

* IP目录提供的IP核
- 优势：
° 在使用多个组件时一般能提供更优化的结果
° 设定和配置简单
- 不足：
° 代码可移植性差
° 需要管理内核

## 实现RAM的性能考虑
* 选择BRAM还是DRAM——深度意味着地址宽度
一般来说 RAM 要求的深度是首要选择标准。高达 64 位深度的存储器阵列一般实现在 LUTRAM 中，其中深度不超过 32 位的映射为每个 LUT 的 2 位，深度达到 64 位的映射为每个LUT 的 1 位。深度更大的 RAM 根据可用资源和综合工具赋值，也可实现在LUTRAM中。
深度超过 256 位的存储器阵列一般实现在块存储器中。赛灵思 FPGA 器件能够灵活地以多种宽度深度组合映射此类阵列。用户需要熟悉这些配置，才能了解代码中更大规模存储器阵列声明所使用的块 RAM 的数量与结构。

* 使用输出流水寄存器
- 与块 RAM 寄存器相比，slice 输出寄存器具有更快的时钟输出时序。使两个寄存器的总读取延迟为3。

* 使用输入流水线寄存器
当 RAM 数组很大并映射到许多原语时，它们可以跨越相当大的die晶片区域。这可能导致地址和控制线上的性能问题。考虑在生成这些信号之后和 RAM 之前添加一个额外的寄存器。为了进一步提高时序，稍后在流程中使用phys_opt_design 来复制此寄存器。无逻辑的寄存器的输入将更容易复制。

## 注意事项

- 避免单端口RAM综合出不必要的(两级)输出寄存器。
- 不能复位RAM但可以对输出寄存器复位。
------
